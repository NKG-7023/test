# 目次
1. [プロジェクトの取り扱い方](#プロジェクトの取り扱い方)
1. [スケジュール](#スケジュール)
1. [ゲーム概要](#ゲーム概要)
1. [タスクリスト](#タスクリスト)
1. [掲示板](#掲示板)
1. [プログラム説明](#プログラム説明)

見出しの深さに関係なく、リンクを貼る際は"#"は一つです。  
結構ていねいに、見出しと各項目で対応したリンクを貼ってます。

# [プロジェクトの取り扱い方](#目次)
- 	README.md  
	基本的にネット上でGithubにあるやつ(リモートリポジトリ)の  
	**mainブランチにあるファイル自体を**編集する。  
-	各個人の独自の編集は、リモートリポジトリのmainブランチではなく、  
	各自が作ったブランチ上とし、**安定動作版となった場合のみ**、  
	mainブランチに追加して良い。
- 	mainブランチへの追加は、**Create Pull Requestまで**を可能とし、  
	Merge(Merge Pull Request)は**相手が承認するまで待つ**。  
	ちなみに、Pull Requestを建てると、相手にメールが行く。
-	commitのコメントはなくても良いが、  
	Pull Requestはコメント(description)を必須とする。

# [スケジュール](#目次)
## 全体
- 	4月中は、各自の学習を続ける。  
	並行してゲームのアイデアが思いつけば、書き加える。

## NKG
ゲームデザイン(プログラム含む)・ドット絵
- 	JavaScriptに習熟する。  
	とりあえずmain.js, engine.jsの中身はおおよそ理解する。
	(4月中を目標)

## Tsubaki
ゲームエンジン制作・作曲・ドット絵
-	4月中旬までに、このREADMEの「プログラム説明」を完成させる

# [ゲーム概要](#目次)  
## コンセプト  
横スクロール型のジャンプアクションで、攻撃はしない  
16*16のスプライトを使用したゲーム。  
色数に縛りは設けない。
## ジャンル
## イメージ

# [タスクリスト](#目次)
- [x] a 
- [ ] f

# [掲示板](#目次)
自由に質問やコメント、思いついたアイデアを書く
-	ドット絵の拡大は、
	image-rendering: pixelatedを使う?

# [プログラム説明](#目次)

## プログラムの流れ
1.	Webページの読み込み(onload)の際、init()を実行
1.	init()にて画面や音声、アセット、ステージを初期化。  
	requestAnimationFrame()でゲームのメインループを駆動。
1.	ゲームメインループ  
	-	update():  
		ゲームの状態(phase)や時間(time)の推移に従って実行内容を変更
	-	render():  
		各種キャラクターやマップの描画等、描画を管理。
	-	各種キャラクターの動き方等は、  
		キャラクターのクラス->update()内に記載。
1.	ゲームは終了することがないので、これが全てです。
## 特記事項
###	**特記事項見出し**
-	[キー入力関連](#キー入力関連)
-	[音声関連](#音声関連)
-	[座標](#座標)
-	[アセット](#アセット)
-	[当たり判定](#当たり判定)

### [キー入力関連](#特記事項見出し)
-	**キーボードを使用する場合**  
	onkeydown: フレームを加算  
	onkeyup: フレームをリセット
-	**ゲームパッドを使用する場合**  
	随時ゲームパッドの接続を取得し、  
	ゲームパッドが一つでも繋がれているときは必ず使用。  
	アナログパッドの軸操作を、閾値によってディジタルに変換。  
	***反対にディジタルのキーボード入力をアナログ値に変換して、  
	プレーヤー操作を滑らかにしてもいいでしょう***

### [音声関連](#特記事項見出し)
音声をWeb上で使用するためには少し複雑な初期化が必要で、  
デバイスによって異なります。  
*タッチデバイスでは指が離されたとき、*  
*マウスではマウスボタンが離されたときに、*  
初期化を行なっています。  
一度画面をクリックしないと音声は再生されないためです。  
(Youtubeなどで一度タップが必要なのと同じ理由)

### [座標](#特記事項見出し)
キャラクターの座標は細かめの精度が欲しいため、  
スクリーン座標(640, 480)よりも100倍の精度で計算し、  
整数のみを取り扱うこととする。  
実数に比べ、飛び飛びの値をとるので管理は楽です。

### [アセット](#特記事項見出し)
アセット(使用素材)はAssetにて全てまとまっている。  
Asset.assetsに、読み込みたいアセットを列挙。  
#### Assetの定義
[変数:](#アセット)
-	assets(連想配列であるassetの配列となっている)  
	assetの要素は次の通り  
	-	type  
		アセットの種類で、読み込み後に振り分ける場所を決める。
		image → Asset.imagesへ  
		sound → Asset.soundへ
	-	name  
		アセットを参照するときに指定する名前。  
		Asset.images[*name*]など
	-	src
		アセットのパス(source)  
		index.htmlの位置からの相対パスを使用する。
-	images
-	sounds  
	アセットの保管場所となっている。  

[メソッド:](#アセット)
-	loadAssets  
	引数:  
	1.	onComplete  
		アセット読み込み後に実行する関数。

	Asset.assetsにある全てのアセットを読み込む。  
	アセットを一つ読み込むごとにカウンタが増え、  
	全て読み込んだときにonCompleteを実行する。  
-	_loadImage  
	引数:  
	1.	asset  
		読み込みたいアセット(type, name, srcをもつ)
	1.	onLoad  
		読み込んだ後に実行するメソッド。
	
	Imageクラスを使用した画像データ読み込み。

-	_loadSound  
	引数:  
	1.	asset  
		読み込みたいアセット(type, name, srcをもつ)
	1.	onLoad  
		読み込んだ後に実行するメソッド。
	
	音声データ読み込み
	ローカルファイルを読み込むのではなく、  
	サーバからデータを取得するような仕様となっている。  
	内部では、サーバにメッセージを送り、音声データを配列データとして取得。  



### [当たり判定](#特記事項見出し)
checkTileCollisionでは、スプライト同士の当たり判定に対応する。
判定時にはプレイヤーは移動前で、
当たり判定によってプレイヤーが可能な移動ベクトルを返す。  
複数プレイヤーが行動したときに、キャラクター判定順の決定は難しいところです。  
壁との接触場所に関しては、ビットフラグで管理している。  
(posベクトルは、プレイヤーの左上座標を保持していることに注意)。  
(右下 | 左下 | 右上 | 左上 **右に行くほど桁は小さい**)  
-	count >= 2
	スプライトの辺が壁に接触する(めり込む)ことに相当。  
	押し戻せばいいだけなので簡単
-	count == 1  
	四隅の角が壁にめり込むことに相当。  
	優先順位を  
	
	<p style="text-align: center;">x座標の押し戻し→y座標の押し戻し</p>

	と決めておく。  
	例えばプレイヤーが右上に動き、右上の角に当たり判定(0010)があったとして、  
	本当は移動ベクトルと壁の交差判定により、  
	壁の左側に当たったのか、下側に当たったのかを区別して、  
	押し戻す方向を変えると厳密な設計とはなるが、  
	おそらくそこまで気にしてもしょうがないので、優先順位を決めておく。  
	x軸の押し戻しを優先させると壁に沿ったジャンプがしやすく、  
	プレイヤーには優しいと言える。

## 関数一覧
###	**関数見出し**

### [テンプレート(関数名をここに書く)](#関数見出し)
引数:
1.	引数名(欲しい型 整数か画像かなど)  
	もし必要なら説明
2.  

返り値と簡単な説明(主に役割や動作)

## 定数一覧
###	**定数見出し**
-	[SCREEN_WIDTH](#SCREEN_WIDTH)
-	[SCREEN_HEIGHT](#SCREEN_HEIGHT)
-	[TIMEBAR_WIDTH](#TIMEBAR_WIDTH)
-	[TILE_SIZE](#TILE_SIZE)
-	[NUM_TILE_X](#NUM_TILE_X)
-	[NUM_TILE_Y](#NUM_TILE_Y)
-	[TIMEMAX](#TIMEMAX)
-	[CLEAR_WAIT](#CLEAR_WAIT)
### [SCREEN_WIDTH](#定数見出し)
### [SCREEN_HEIGHT](#定数見出し)
スクリーンのサイズを示す(整数)

### [TIMEBAR_WIDTH](#定数見出し)
スクリーン上におけるタイムゲージの幅(整数)

### [TILE_SIZE](#定数見出し)
タイル(スプライト)1枚のサイズ(整数)

### [NUM_TILE_X](#定数見出し)
### [NUM_TILE_Y](#定数見出し)
一画面の中に配置できるタイルの数。  
縦横比が1ではないので、X,Yで値は異なる。

### [TIMEMAX](#定数見出し)
制限時間の最大値(整数)

### [CLEAR_WAIT](#定数見出し)
ゲームクリアの際の停止時間(整数)  
急に画面が初期状態にリセットするのを防ぐ

## ゲームエンジンの構成
### **クラスの構成**
-	[Vec2](#Vec2)
-	[Rectangle](#Rectangle)
-	[GameEvent](#GameEvent)
-	[EventDispatcher](#EventDispatcher)
	-	[GameObject](#GameObject)
		- [Chara](#Chara)
			- [Player](#Player)
-	[Sprite](#Sprite)

### 各種のクラス詳説
### [テンプレート(クラス名をここに書く。)](#クラスの構成)
変数:
1.	変数名(欲しい型)  
	もし必要なら説明
2.  

メソッド:  
1.	メソッド名  
	簡単な説明(返り値や動作など)

### [Vec2](#クラスの構成)
2次元のベクトルを表す。  
変数:
1.	x, y(整数)
2.	length(実数)  
	ベクトルの長さを取得

メソッド:
1.	add  
	引数: v(Vec2)  
	各要素の和を取る。  
	v1.add(v2);

2.	addPt  
	引数: x, y(整数)  
	各要素の和を取る。(各座標を引数とする)  

3.	multiply  
	引数: a(実数)  
	各要素を定数倍する。  
	v1.multiply(1.5);

4.	dot  
	引数: v(Vec2)  
	各要素の内積を取る。    

### [Rectangle](#クラスの構成)
矩形を表す。

### [GameEvent](#クラスの構成)
イベントの対象となったObjectをもつ。

### [EventDispatcher](#クラスの構成)
イベントを発火出来るクラスであることを示す。
-	addEventListener  
	typeで表されるイベントが起きたときに実行したい関数(callback)をあらかじめ追加。  
-	removeEventListener
	addの反対で、削除
-	dispatchEvent  
	イベントを発火する。  
	if (オブジェクトが接触) {  
	<span>&emsp;&emsp;</span>obj1.dispatchEvent('hit', new GameEvent(obj1));  
	<span>&emsp;&emsp;</span>obj2.dispatchEvent('hit', new GameEvent(obj2));  
	}  
	のように使う。  
	**GameEventを拡張することで、多くの情報を持てる。**  
	例えば、当たった側だけでなく、当てた側も情報に持たせるなど。

### [GameObject](#クラスの構成)
画像をもつゲーム上に登場するオブジェクトである。  
当たり判定や描画は実装されている。

### [Chara](#クラスの構成)
ただのオブジェクトのみならず、向きを考慮している。  
アニメーション等も追加されるだろう。

### [Player](#クラスの構成)
操作対象となるプレイヤーを示す。  
updateで操作部を定義している。

### [Sprite](#クラスの構成)
スプライトを表す。  
矩形と画像から構成される。
